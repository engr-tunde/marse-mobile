"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Accordion = void 0;
var _react = require("react");
var _reactNative = require("react-native");
var _reactNativeReanimated = _interopRequireWildcard(require("react-native-reanimated"));
var _jsxRuntime = require("react/jsx-runtime");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const AnimatedPressable = _reactNativeReanimated.default.createAnimatedComponent(_reactNative.Pressable);
const AccordionContext = /*#__PURE__*/(0, _react.createContext)({
  isOpen: false,
  accordionIsOpen: () => {}
});

// type AccordionProvider = ContextType<typeof AccordionContext>;

// Internal Hook
const useAccordion = () => {
  const context = (0, _react.useContext)(AccordionContext);
  if (!context) {
    throw new Error('useAccordion must be used within a Accordion.Provider');
  }
  return context;
};
function Provider({
  children,
  isOpen: initialIsOpen,
  onChange,
  style,
  ...rest
}) {
  const [isOpen, accordionIsOpen] = (0, _react.useState)(!!initialIsOpen);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(AccordionContext.Provider, {
    value: {
      isOpen,
      accordionIsOpen: () => {
        onChange?.(!isOpen);
        accordionIsOpen(prev => {
          return !prev;
        });
      }
    },
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNativeReanimated.default.View, {
      style: [style, {
        overflow: 'hidden'
      }],
      layout: _reactNativeReanimated.LinearTransition.springify().damping(80).stiffness(200),
      ...rest,
      children: children
    })
  });
}
function Header({
  children
}) {
  const {
    accordionIsOpen
  } = useAccordion();
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(AnimatedPressable, {
    onPress: () => accordionIsOpen(),
    children: children
  });
}
function Icon({
  children,
  rotation = 'clockwise'
}) {
  const {
    isOpen
  } = useAccordion();
  const rotate = (0, _reactNativeReanimated.useDerivedValue)(() => {
    return (0, _reactNativeReanimated.withSpring)(isOpen ? (rotation === 'clockwise' ? -1 : 1) * 180 : 0, {
      damping: 80,
      stiffness: 200
    });
  }, [isOpen, rotation]);
  const stylez = (0, _reactNativeReanimated.useAnimatedStyle)(() => {
    return {
      transform: [{
        rotate: `${rotate.value}deg`
      }]
    };
  });
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNativeReanimated.default.View, {
    style: stylez,
    layout: _reactNativeReanimated.LinearTransition.springify().damping(80).stiffness(200),
    children: children
  });
}
function Expanded({
  children,
  ...rest
}) {
  const {
    isOpen
  } = useAccordion();
  if (!isOpen) {
    return;
  }
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(Content, {
    ...rest,
    children: children
  });
}
function Collapsed({
  children,
  ...rest
}) {
  const {
    isOpen
  } = useAccordion();
  if (isOpen) {
    return;
  }
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(Content, {
    ...rest,
    children: children
  });
}
function Always({
  children,
  ...rest
}) {
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(Content, {
    ...rest,
    children: children
  });
}
function Content({
  children,
  style,
  ...rest
}) {
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNativeReanimated.default.View, {
    entering: _reactNativeReanimated.FadeIn.springify().damping(80).stiffness(200),
    exiting: _reactNativeReanimated.FadeOut.springify().damping(80).stiffness(200),
    layout: _reactNativeReanimated.LinearTransition.springify().damping(80).stiffness(200),
    style: [style, {
      overflow: 'hidden'
    }],
    ...rest,
    children: children
  });
}
function Sibling({
  children,
  ...rest
}) {
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNativeReanimated.default.View, {
    layout: _reactNativeReanimated.LinearTransition.springify().damping(80).stiffness(200),
    ...rest,
    children: children
  });
}
const Accordion = exports.Accordion = {
  /**
   * The main component that will handle the state of the accordion.
   *
   * @param isOpen boolean
   * @param onChange (value: boolean) => void
   */
  Accordion: Provider,
  /**
   * The header of the accordion.
   */
  Header,
  /**
   * The component that will wrap any children and it will apply a rotation to it.
   *
   * @param children
   * @param rotation clockwise | counter-clockwise
   */
  HeaderIcon: Icon,
  /**
   * This is the content that will be displayed when the accordion is open
   */
  Expanded,
  /**
   * This is the content that will be displayed when the accordion is closed
   */
  Collapsed,
  /**
   * This is the content that will always be displayed
   */
  Always,
  /**
   *
   * This is a component that will add the layout transition to any
   * sibling components. Useful when you are rendering other components
   * that are not direct children of the Accordion component.
   */
  Sibling
};
var _default = exports.default = Accordion;
//# sourceMappingURL=index.js.map